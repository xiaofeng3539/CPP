#include<iostream>
#include<stdexcept>
using namespace std;


template<typename T>
class Queue {
private:
	struct Node {
		T data;
		Node* next;
		Node(T d) : data(d), next(NULL) {}
	};

	Node* front;
	Node* rear;
	int size;

public:
	Queue() : front(NULL), rear(NULL), size(0) {}
	~Queue();
	void enqueue(T element);
	T dequeue();
	T getFront() const;
	int getSize() const;
	bool empty() const;


};
template<typename T>
Queue<T>::~Queue() {
	while (front) {
		Node* temp = front;
		front = front->next;
		delete temp;
	}
}

template<typename T>
void Queue<T>::enqueue(T element) {
	if (rear == NULL) {
		rear = new Node(element);
		front = rear;
	}
	else {
		rear->next = new Node(element);
		rear = rear->next;
	}
	size++;
}

template<typename T>
T Queue<T>::dequeue() {
	if (front == NULL) {
		throw std::underflow_error("Queue is empty");
	}
	T element = front->data;
	Node* temp = front;
	front = front->next;
	delete temp;
	--size;
	if (size == 0) rear = NULL;
	return element;

}

template<typename T>
T Queue<T>::getFront() const {
	if (front == NULL) {
		throw std::underflow_error("Queue is empty");
	}
	return front->data;
}

template<typename T>
int Queue<T>::getSize() const {
	return size;
}

template<typename T>
bool Queue<T>::empty() const {
	return size==0;
}

class MyStack {
private:
	Queue<int> q1, q2;
public:
	MyStack() {}

	void push(int x) {
		q1.enqueue(x);
	}

	int pop() {
		while (q1.getSize() > 1) {
			q2.enqueue(q1.dequeue());

		}
		int result = q1.dequeue();
		while (!q2.empty()) {
			q1.enqueue(q2.dequeue());
		}
		return result;
	}

	int top() {
		while (q1.getSize() > 1) {
			q2.enqueue(q1.dequeue());

		}
		int result = q1.dequeue();
		q2.enqueue(result);
		while (!q2.empty()) {
			q1.enqueue(q2.dequeue());
		}
		return result;
	}
	bool empty() {
		return q1.empty() && q2.empty();
	}

};
	

int main() {
	MyStack stack;
	stack.push(1);
	stack.push(2);
	cout << "top: " << stack.top() << endl;
	cout << "pop: " << stack.pop() << endl;
	cout << "empty: " << (stack.empty() ? "true" : "false") << endl;
	return 0;
}
